// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("PRISMA_DB_URL")
}

model User {
  id String @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clerkId String @unique
  email String @unique
  name String?
  username String @unique

  pkm_history PkmHistory[]
  epiphany_items PkmEpiphany[]
  inbox_items PkmInbox[]
  passing_thought_items PkmPassingThought[]
  todo_items PkmTodo[]
  voided_passing_thought_items PkmVoid[]
  trash_items PkmTrash[]

  suites Suite[]
}

model PkmHistory {
  history_id String @id @default(uuid()) @db.Uuid
  model_id String @default(uuid()) @db.Uuid
  model_type String
  createdAt DateTime @default(now())

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  // We'll treat a null suite id as a message waiting for you at the front desk. I don't know what the term for this is though
  suite Suite? @relation(fields: [suite_id], references: [id], onDelete: Cascade)
  suite_id String? @db.Uuid

  epiphany_item PkmEpiphany?
  inbox_item PkmInbox?
  passing_thought_item PkmPassingThought?
  todo_item PkmTodo?
  void_item PkmVoid?
  trash_item PkmTrash?

  is_current Boolean @default(false)

  // Add an index for non unique foreign keys
  @@index([user_id])
  @@index([suite_id])
}

model PkmEpiphany {
  history_id String @id @default(uuid()) @db.Uuid
  model_id String @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content String @default("Your epiphany item content here")
  name String @default("New epiphany item")
  summary String @default("Summarise your epiphany item here")

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  // Not sure how to achieve polymorphism. I'm not sold on https://github.com/prisma/prisma/discussions/11108
  history PkmHistory @relation(fields: [history_id], references: [history_id], onDelete: Cascade)

  // Add an index for non unique foreign keys
  @@index([user_id])
}

model PkmInbox {
  history_id String @id @default(uuid()) @db.Uuid
  model_id String @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  content String @default("Your inbox item content here")
  name String @default("New inbox item")
  summary String @default("Summarise your inbox item here")

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  history PkmHistory @relation(fields: [history_id], references: [history_id], onDelete: Cascade)

  // Add an index for non unique foreign keys
  @@index([user_id])
}

model PkmPassingThought {
  history_id String @id @default(uuid()) @db.Uuid
  model_id String @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  content String @default("Your passing thought item content here")
  name String @default("New passing thought item")
  summary String @default("Summarise your passing thought item here")
  void_at DateTime

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  history PkmHistory @relation(fields: [history_id], references: [history_id], onDelete: Cascade)

  // Add an index for non unique foreign keys
  @@index([user_id])
}

model PkmTodo {
  history_id String @id @default(uuid()) @db.Uuid
  model_id String @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  content String @default("Your todo item content here")
  name String @default("New todo item")
  summary String @default("Summarise your todo item here")

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  history PkmHistory @relation(fields: [history_id], references: [history_id], onDelete: Cascade)

  // Add an index for non unique foreign keys
  @@index([user_id])
}

model PkmVoid {
  history_id String @id @default(uuid()) @db.Uuid
  model_id String @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  content String @default("Your void item content here")
  name String @default("New void item")
  summary String @default("Summarise your void item here")

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  history PkmHistory @relation(fields: [history_id], references: [history_id], onDelete: Cascade)

  // Add an index for non unique foreign keys
  @@index([user_id])
}

model PkmTrash {
  history_id String @id @default(uuid()) @db.Uuid
  model_id String @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  content String @default("Your trash item content here, though this should have been specified by the item before being moved to the trash")
  name String @default("New trash item, though this should have been specified by the item before being moved to the trash")
  summary String @default("Summarise your trash item here, though this should have been specified by the item before being moved to the trash")

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  history PkmHistory @relation(fields: [history_id], references: [history_id], onDelete: Cascade)

  // Add an index for non unique foreign keys
  @@index([user_id])
}

// A convention I might try is having the Foyer Suite id be the same id as the user id in the backend, but alias it as UUID Nil on the frontend
// Can easily run this query to create the Foyer Suite for all users, but Prisma doesn't support data migrations
// insert into "Suite" (id, name, description, user_id, "updatedAt") select id, 'foyer' as name, 'Auto created foyer' as description, id, current_timestamp as "updatedAt" from "User"
model Suite {
  id String @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id String @db.Uuid

  parent_suite Suite? @relation("Suiteception", fields: [parent_suite_id], references: [id], onDelete: Cascade)
  parent_suite_id String? @db.Uuid
  sub_suites Suite[] @relation("Suiteception")

  name String @default("Please give your suite a name")
  description String @default("Please describe the suite")

  // Add an index for non unique foreign keys
  @@index([user_id])

  pkm_history PkmHistory[]
}